\chapter{Component Design and Interfaces}
\label{component-design}

This chapter is focused on the general design of the components used in the implementation of TCC as well as their interfaces. It is divided into the three main parts of the general TCC implementation (see section \ref{archi-intro}): the client side (browser extension), the service side (any webstore implementing the TCC protocol) and the transaction manager. The sections are divided in two parts: the design part, which focuses on how the various part of the implementation of the TCC protocol have been designed to cooperate together, and the interface part which targets the means by which those components may be addressed.\\

\section{Client Side}
The client side is composed by a browser extended with an extension application that can manage to filter confirmation links and send them to the transaction manager. The components this section is going to focus on are the GUI and the filter, situated in the browser extension, and not on the coordination between the browser and its extension, nor the communication protocols used by the browser to contact the service and the transaction manager.

\subsection{Design}
\label{tcc-client-side-design}
As mentioned in the introduction of this section, the client side is designed with two main components: the GUI and the filter. The GUI's task is primarily to let the user see what's happening. At first, it needs to login to the transaction manager and store the cookie. Once this is done, the GUI will show the current transactions in progress for the logged user. From the GUI, the user can trigger the confirmation of the current transactions in progress or the deletion of one of them. So basically this component encapsulates everything that concerns the control of the transaction manager.\\
For what concerns the filter, this is a small component that filters the headers of every request done by the browser. If the filter detects a fingerprint sent by a service TCC-capable, then it searches for the confirmation link that should be stored in the header. Once the link is taken, it performs a {\tt GET} request to receive additional information about the transaction, and sends them to the transaction manager. It's highly recommended to performs these two steps asynchronously, to avoid the user to perceive response time and delays.

\subsection{Interfaces}
There are no real interfaces to which somebody or something can attach to both components. In fact, the both of them connects to some other interface, but they do not have one to be connected to (see section \ref{archi-tcc-logical-view} and especially image \ref{tcc-logical-view}). It may seem strange that the two components do not interact together. The reason is that they simply don't need to. The GUI logs in into the service and receives back the current transactions in progress. Those are filled one after the other by the filter component, that filters the confirmation links, gets the additional information about the transactions in progress and send everything to the transaction manager.

\section{Service Side}
The service side is a simple website that offers something to the users, that can be books, items, or plane flights. This section omits everything related to the design of such websites, but focuses its attention on how the service is modeled to become TCC-capable. We will see how it is designed and which interfaces gives it access to.

\subsection{Design}
To be capable of doing TCC transactions, the service has to have the power to "reserve" the item, instead of selling them right away. This can be done by creating a new state for the items that is neither bought nor available. The idea is that after receiving a {\tt POST} request, the service creates a new resource that is "hid" by the means of an id. Ideally, this resource can only be accessed by the user that performed the reservation, since he is the one receiving the link to it (confirmation link). This resource should be susceptible to {\tt GET}, {\tt PUT} and {\tt DELETE} methods, in fact with a {\tt GET} request it returns some information (for example the timeout limit, the payment link, etc.), with a {\tt DELETE} request, it cancel itself as resource (effectively canceling the reservation) and with a {\tt PUT} request, it confirms the purchase and removes itself.\\
Of course, the work to create this new resource is not that simple. The service provider in fact may want to keep track of the current transaction status by setting a timeout, which corresponds to the timeout given to the user, which when expired makes the item back available. These timeouts have to subsequently made persistent by storing the current transactions in progress into a database, to recover from failures. This is just one way to recover current transactions from failures, from the point of view of the service side, other means are welcome, as long as they provide persistence and recovery of the transactions and timeouts.

\subsection{Interfaces}
The interface given by the TCC service are those given by any RESTful service on the cloud. The filter situated on the browser extension does not really "connects" to it, but uses the result of an HTTP method to check the possibility to execute the TCC protocol. For what concerns the transaction manager, it uses again the interfaces given by REST to contact the service and either confirm the transactions or delete one of them.

\section{Transaction Manager} 
The transaction manager is a service on the cloud; its work is to receive transactions in progress by users registered to it. Users may later confirm those transactions or delete them. The work of the transaction manager is to keep track of every transaction for any user, keep track of their timeouts and execute requests as the user needs. 

\subsection{Design}
This last part is composed by two pieces, a small piece capable of registering or logging in users and the big part which stores transactions and executes methods on the service.\\
The login / registration component may be a simple web page with a form, or a RESTful interface that accepts {\tt POST} requests which sends either a login or a registration form. In either of the two cases, this component should communicate to the database and register users or check for the login.\\
For what concerns the most interesting part, it has to be capable of receiving chunks of data which represent ongoing transactions. It has to store them keeping into account all the information received plus the user that sent the request. Once the same user requires back all his transactions in progress (that is from the GUI), the transaction manager has to retrieve all of them back from the database and send them to the user. Lastly, when the user decides what to do (either delete some or all of the transactions or confirm them), the transaction manager has to be capable of sending to the service either a {\tt DELETE} request or many different {\tt PUT} requests to many different services.\\
Also in this case, persistence and recoverability are key factors. The database storage helps when the transaction manager has a failure, since it can recover every ongoing transaction for every user. The same thing happen when it comes to a failure during the confirmation phase (see section \ref{tcc-guaranteeing-atomicity}), since the {\tt PUT} operation is idempotent, the transaction manager can retry that phase on and on until the transactions are all confirmed.
\subsection{Interfaces}
The interface to dialogue with the login / registration component can be, as previously stated, a simple web page with forms as well as a RESTful interface that accepts {\tt POST} requests containing the data to login a user or register him.\\
As for the transaction manager, the GUI of the browser extension needs data to be filled, so again a RESTful interface is given to give access to the current transactions in progress. Especially in this case a {\tt GET} request is needed to ask for the ongoing transactions, while a {\tt DELETE} request provided with the id of the transaction will trigger a {\tt DELETE} for a transaction. Instead, a {\tt PUT} request will trigger the confirmation phase.